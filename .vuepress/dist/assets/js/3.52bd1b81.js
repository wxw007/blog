(window.webpackJsonp=window.webpackJsonp||[]).push([[3],{167:function(t,e,s){t.exports=s.p+"assets/img/1.4fd85c39.jpg"},171:function(t,e,s){"use strict";s.r(e);var r=[function(){var t=this.$createElement,e=this._self._c||t;return e("h1",{attrs:{id:"js基础"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js基础","aria-hidden":"true"}},[this._v("#")]),this._v(" JS基础")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"js数据数据类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js数据数据类型","aria-hidden":"true"}},[this._v("#")]),this._v(" js数据数据类型")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",[e("li",[this._v("原始类型 "),e("strong",[this._v("(6个)")])])])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ul",[s("li",[t._v("boolean")]),t._v(" "),s("li",[t._v("null")]),t._v(" "),s("li",[t._v("undefined")]),t._v(" "),s("li",[t._v("string")]),t._v(" "),s("li",[t._v("number")]),t._v(" "),s("li",[t._v("symbol")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("原始类型都是按值传递")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",{attrs:{start:"2"}},[e("li",[this._v("引用类型")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("object")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"判断数据类型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#判断数据类型","aria-hidden":"true"}},[this._v("#")]),this._v(" 判断数据类型")])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ul",[s("li",[s("code",[t._v("typeof")]),t._v(" 对于原始类型来说，除了 "),s("code",[t._v("null")]),t._v(" 都可以显示正确的类型")]),t._v(" "),s("li",[s("code",[t._v("typeof")]),t._v(" 对于对象来说，除了函数都会显示 "),s("code",[t._v("object")]),t._v(" ，所以说 "),s("code",[t._v("typeof")]),t._v(" 并不能准确判断变量到底是什么类型")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[e("code",[this._v("typeof")]),this._v(" 只能判断原始类型")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[e("code",[this._v("instanceof")]),this._v(" 用来判断A是否为B的实例，表达式为：A "),e("code",[this._v("instanceof")]),this._v(" B，如果A是B的实例，则返回true，否则返回false。 "),e("code",[this._v("instanceof")]),this._v(" 检测的是原型，内部机制是通过判断对象的原型链中是否有类型的原型。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[e("code",[this._v("instanceof")]),this._v(" 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[e("code",[this._v("constructor")]),this._v(" : ' '.constructor === String")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("null 和 undefined 无constructor，这种方法判断不了。 如果自定义对象，开发者重写prototype之后，原有的constructor会丢失。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[e("code",[this._v("Object.prototype.toString()")]),this._v(" toString()是Object的原型方法，调用该方法，默认返回当前对象的[[Class]]。这是一个内部属性，其格式为[object Xxx], 其中Xxx就是对象的类型。对于 "),e("code",[this._v("Object")]),this._v(" 对象，直接调用toString()就能返回[object Object], 而对于其他对象，则需要通过call、apply来调用才能返回正确的类型信息。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("Object.prototype.toString.call('') // [object String]\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("Object.prototype.toString()")]),this._v(" 是最推荐的")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"this"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#this","aria-hidden":"true"}},[this._v("#")]),this._v(" this")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"普通函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#普通函数","aria-hidden":"true"}},[this._v("#")]),this._v(" 普通函数")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("function foo() {\n  console.log(this.a)\n}\nvar a = 1\nfoo()\n\nconst obj = {\n  a: 2,\n  foo: foo\n}\nobj.foo()\n\nconst c = new foo()\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("对于直接调用 foo 来说，不管 foo 函数被放在了什么地方，this 一定是 window")]),this._v(" "),e("li",[this._v("对于 obj.foo() 来说，我们只需要记住，谁调用了函数，谁就是 this，所以在这个场景下 foo 函数中的 this 就是 obj 对象")]),this._v(" "),e("li",[this._v("对于 new 的方式来说，this 被永远绑定在了 c 上面，不会被任何方式改变 this")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"箭头函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#箭头函数","aria-hidden":"true"}},[this._v("#")]),this._v(" 箭头函数")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("function a() {\n  return () => {\n    return () => {\n      console.log(this)\n    }\n  }\n}\nconsole.log(a()()())\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("let a = {}\nlet fn = function () { console.log(this) }\nfn.bind().bind(a)() // => ?\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"this的优先级"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#this的优先级","aria-hidden":"true"}},[this._v("#")]),this._v(" this的优先级")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("img",{attrs:{src:s(167),alt:"this流程图"}})])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"闭包"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#闭包","aria-hidden":"true"}},[this._v("#")]),this._v(" 闭包")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"什么是闭包？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#什么是闭包？","aria-hidden":"true"}},[this._v("#")]),this._v(" 什么是闭包？")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("例子: 闭包实现一个函数，每次调用返回值加1\nfunction a(){\n    var n = 1;\n    return function(){\n       return n++\n    }\n}\nvar b = a()\n\nb() // 1\nb() // 2\nb() // 3\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"闭包的使用场景"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#闭包的使用场景","aria-hidden":"true"}},[this._v("#")]),this._v(" 闭包的使用场景")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",[e("li",[this._v("实现私有成员。")]),this._v(" "),e("li",[this._v("保护命名空间，避免污染全局变量。")]),this._v(" "),e("li",[this._v("缓存变量。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("常见的用闭包解决循环打印数值一样的问题")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"使用闭包的注意事项"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#使用闭包的注意事项","aria-hidden":"true"}},[this._v("#")]),this._v(" 使用闭包的注意事项")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",[e("li",[e("strong",[this._v("内存泄漏")]),this._v(" - 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题")]),this._v(" "),e("li",[this._v("如果内部函数的变量和外部函数的变量名相同时，那么内部函数再也无法指向外部函数那个同名的变量")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"浅拷贝、深拷贝"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浅拷贝、深拷贝","aria-hidden":"true"}},[this._v("#")]),this._v(" 浅拷贝、深拷贝")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"浅拷贝"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#浅拷贝","aria-hidden":"true"}},[this._v("#")]),this._v(" 浅拷贝")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",[e("li",[e("code",[this._v("Object.assign")])]),this._v(" "),e("li",[this._v("扩展运算符 "),e("code",[this._v("...")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"深拷贝"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝","aria-hidden":"true"}},[this._v("#")]),this._v(" 深拷贝")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("通常用转字符串的方法进行深拷贝 "),e("code",[this._v("JSON.parse(JSON.stringify(object))")]),this._v(" 。\n但是此方法存在局限性")])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ul",[s("li",[t._v("会忽略 "),s("code",[t._v("undefined")])]),t._v(" "),s("li",[t._v("会忽略 "),s("code",[t._v("symbol")])]),t._v(" "),s("li",[t._v("不能序列化函数")]),t._v(" "),s("li",[t._v("不能解决循环引用的对象")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("let obj = {\n  a: 1,\n  b: {\n    c: 2,\n    d: 3,\n  },\n}\nobj.c = obj.b\nobj.e = obj.a\nobj.b.c = obj.c\nobj.b.d = obj.b\nobj.b.e = obj.b.c\nlet newObj = JSON.parse(JSON.stringify(obj))\nconsole.log(newObj)  //报错\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("let a = {\n  age: undefined,\n  sex: Symbol('male'),\n  jobs: function() {},\n  name: 'yck'\n}\nlet b = JSON.parse(JSON.stringify(a))\nconsole.log(b) // {name: \"yck\"} 只剩下name\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"原型和原型链"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原型和原型链","aria-hidden":"true"}},[this._v("#")]),this._v(" 原型和原型链")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"原型"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原型","aria-hidden":"true"}},[this._v("#")]),this._v(" 原型")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("每个 JS 对象都有 "),e("code",[this._v("__proto__")]),this._v(" 属性，这个属性指向了原型，实例的 "),e("code",[this._v("__proto__")]),this._v(" 属性(原型) 等于其构造函数的 "),e("code",[this._v("prototype")]),this._v(" 。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"原型链"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#原型链","aria-hidden":"true"}},[this._v("#")]),this._v(" 原型链")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("对象的 "),e("code",[this._v("__proto__")]),this._v(" 属性指向原型， "),e("code",[this._v("__proto__")]),this._v(" 将对象和原型连接起来组成了原型链。")])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("p",[t._v("当在一个对象 obj 上访问某个属性时，如果不存在于 obj，那么便会去对象的原型也就是 "),s("code",[t._v("obj.__proto__")]),t._v(" 上去找这个属性。如果有则返回这个属性，没有则去对象 obj 的原型的原型也就是 "),s("code",[t._v("obj.__proto__.__proto__")]),t._v(" 去找，重复以上步骤。一直到访问纯对象的原型的原型 "),s("code",[t._v("{}.__proto.__proto__")]),t._v(" ，也就是 "),s("code",[t._v("null")]),t._v(" ，直接返回 "),s("code",[t._v("undefined")]),t._v(" 。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"new-运算符做了什么"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#new-运算符做了什么","aria-hidden":"true"}},[this._v("#")]),this._v(" new 运算符做了什么")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("function F(){\n  console.log('这是构造函数')\n}\n\n// new 做了以下四步\nvar obj = {}; // 1. 创建一个空对象 obj\nobj.__proto__ = F.prototype; // 2. 将空对象的 __proto__ 指向F函数对象的prototype对象\nF.call(obj); // 3. 将F函数的 this 指向 obj, 并执行 F\nreturn obj; // 返回 obj\n\n// 自己实现一个 new 方法 \nfunction myNew(){\n  var obj = {}; // 1. 创建一个空对象 obj\n  var Constructor = [].shift.call(arguments) //2. 获取构造函数\n  obj.__proto__ = Constructor.prototype; //3. 将空对象的 __proto__ 指向构造函数的prototype对象\n  var result = Constructor.apply(obj, arguments); //4. 将 this 指向 obj, 并执行Constructor函数\n  return typeof result === \"object\" ? result : obj;//5. 如果返回值是一个对象就返回该对象，否则返回构造函数的一个实例对象\n}\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"var、let、const-区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#var、let、const-区别","aria-hidden":"true"}},[this._v("#")]),this._v(" var、let、const 区别")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("函数提升优先于变量提升，函数提升会把整个函数挪到作用域顶部，变量提升只会把声明挪到作用域顶部。")]),this._v(" "),e("li",[this._v("var 存在提升，我们能在声明之前使用。let、const 因为暂时性死区的原因，不能在声明前使用。")]),this._v(" "),e("li",[this._v("var 在全局作用域下声明变量会导致变量挂载在 window 上，其他两者不会。")]),this._v(" "),e("li",[this._v("let 和 const 作用基本一致，但是后者声明的变量不能再次赋值。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"模块化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模块化","aria-hidden":"true"}},[this._v("#")]),this._v(" 模块化")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"模块化的好处"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模块化的好处","aria-hidden":"true"}},[this._v("#")]),this._v(" 模块化的好处")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("解决命名冲突")]),this._v(" "),e("li",[this._v("提供复用性")]),this._v(" "),e("li",[this._v("提高代码可维护性")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"模块化的方式"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模块化的方式","aria-hidden":"true"}},[this._v("#")]),this._v(" 模块化的方式")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",[e("li",[this._v("立即执行函数")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("(function(globalVariable){\n   globalVariable.test = function() {}\n   // ... 声明各种变量、函数都不会污染全局作用域\n})(globalVariable)\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",{attrs:{start:"2"}},[e("li",[this._v("AMD和CMD (现已比较少使用)")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("// AMD\ndefine(['./a', './b'], function(a, b) {\n  // 加载模块完毕可以使用\n  a.do()\n  b.do()\n})\n// CMD\ndefine(function(require, exports, module) {\n  // 加载模块\n  // 可以把 require 写在函数体的任意地方实现延迟加载\n  var a = require('./a')\n  a.doSomething()\n})\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",{attrs:{start:"3"}},[e("li",[this._v("CommonJS")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("// a.js\nmodule.exports = {\n    a: 1\n}\n// or \nexports.a = 1\n\n// b.js\nvar module = require('./a.js')\nmodule.a // -> log 1\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",{attrs:{start:"4"}},[e("li",[this._v("ES Module")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("// 引入模块 API\nimport XXX from './a.js'\nimport { XXX } from './a.js'\n// 导出模块 API\nexport function a() {}\nexport default function() {}\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"proxy"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#proxy","aria-hidden":"true"}},[this._v("#")]),this._v(" Proxy")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("Vue3.0 中将会通过 "),e("code",[this._v("Proxy")]),this._v(" 来替换原本的 "),e("code",[this._v("Object.defineProperty")]),this._v(" 来实现数据响应式。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("let p = new Proxy(target, handler)\n")])])])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("p",[s("code",[t._v("target")]),t._v(" 代表需要添加代理的对象， "),s("code",[t._v("handler")]),t._v(" 用来自定义对象中的操作，比如可以用来自定义 "),s("code",[t._v("set")]),t._v(" 或者 "),s("code",[t._v("get")]),t._v(" 函数。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"数组遍历方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数组遍历方法","aria-hidden":"true"}},[this._v("#")]),this._v(" 数组遍历方法")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("var arr = [1, 2, 3]\nfor(var i = 0; i < arr.length; i++) { // 这里的i是代表数组的下标\n    console.log(i); // 0, 1, 2\n};\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",{attrs:{start:"2"}},[e("li",[e("h3",{attrs:{id:"优化的-for-循环"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#优化的-for-循环","aria-hidden":"true"}},[this._v("#")]),this._v(" 优化的 for 循环")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("var arr = [1, 2, 3]\nfor(var i = 0, len = arr.length; i < len; i++) { // 这里的i是代表数组的下标\nconsole.log(i); // 0, 1, 2 };　\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",{attrs:{start:"3"}},[e("li",[e("h3",{attrs:{id:"for-of-遍历-这种遍历支持es6"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#for-of-遍历-这种遍历支持es6","aria-hidden":"true"}},[this._v("#")]),this._v(" for...of...遍历(这种遍历支持ES6)")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("var arr = [1, 2, 3]\nfor(var item of arr) { // item代表数组里面的元素\n    console.log(item); // 1, 2, 3\n};　\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[e("p",[this._v("这是最简洁、最直接的遍历数组元素的语法")])]),this._v(" "),e("li",[e("p",[this._v("这个方法避开了for-in循环的所有缺陷")])]),this._v(" "),e("li",[e("p",[this._v("与forEach()不同的是，它可以正确响应break、continue和return语句")])]),this._v(" "),e("li",[e("p",[this._v("性能要好于forin，但仍然比不上普通for循环")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",{attrs:{start:"4"}},[e("li",[e("h3",{attrs:{id:"foreach"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#foreach","aria-hidden":"true"}},[this._v("#")]),this._v(" forEach()")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("var arr = [1, 2, 3];\narr.forEach((item, index, arr) => { // item为arr的元素，index为下标，arr原数组\n    console.log(item); // 1, 2, 3\n    console.log(index); // 0, 1, 2\n    console.log(arr); // [1, 2, 3]\n});\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("这种遍历便捷还是挺便捷的，看起来优雅，对目标数组的操作很人性化，要元素给元素，要下标给下标，但是当某种情况你想"),e("strong",[this._v("中断遍历")]),this._v("的时候，你就会感觉它就像鸡肋，食之无味，弃之可惜。由于foreach是Array型自带的，对于一些非这种类型的，无法直接使用(如NodeList)，所以才有了这个变种，使用这个变种可以让类似的数组拥有foreach功能。而且forEach的性能也会比普通的for循环弱。又下面的例子我们可以看到，我们常用的return false是可以终止代码继续往下执行的，但是在forEach遍历中，"),e("strong",[this._v("并没有终止循环")]),this._v("，所以在用forEach的时候，要考虑使用场景了。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",{attrs:{start:"5"}},[e("li",[e("h3",{attrs:{id:"some"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#some","aria-hidden":"true"}},[this._v("#")]),this._v(" some()")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("var arr = [1, 2, 3];\narr.some((item, index, arr) => { // item为数组中的元素，index为下标，arr为目标数组\n    console.log(item); // 1, 2, 3\n    console.log(index); // 0, 1, 2\n    console.log(arr); // [1, 2, 3]  \n})\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[e("p",[this._v("some作为一个用来检测数组是否满足一些条件的函数存在，同样是可以用作遍历的函数签名同forEach，有区别的是当任一callback返回值匹配为true则会直接返回true，如果所有的callback匹配均为false，则返回false。")])]),this._v(" "),e("li",[e("p",[this._v("some() 方法会依次执行数组的每个元素：")])]),this._v(" "),e("li",[e("p",[this._v("如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。")])]),this._v(" "),e("li",[e("p",[this._v("如果没有满足条件的元素，则返回false。")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",{attrs:{start:"6"}},[e("li",[e("h3",{attrs:{id:"every"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#every","aria-hidden":"true"}},[this._v("#")]),this._v(" every()")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("var arr = [1, 2, 3];\narr.every((item, index, arr) => { // item为数组中的元素，index为下标，arr为目标数组\n    return item > 0; // true\n    return index == 0; // false\n})\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("every() 方法用于检测数组所有元素是否都符合指定条件（通过函数提供）。")]),this._v(" "),e("li",[this._v("every() 方法使用指定函数检测数组中的所有元素：")]),this._v(" "),e("li",[this._v("如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。")]),this._v(" "),e("li",[this._v("如果所有元素都满足条件，则返回 true。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",{attrs:{start:"7"}},[e("li",[e("h3",{attrs:{id:"filter"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#filter","aria-hidden":"true"}},[this._v("#")]),this._v(" filter()")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("var arr = [1, 2, 3];\narr.filter(item => { // item为数组当前的元素\n    return item > 1; // [2, 3]\n})\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",{attrs:{start:"8"}},[e("li",[e("h3",{attrs:{id:"map"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#map","aria-hidden":"true"}},[this._v("#")]),this._v(" map()")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("var arr = [1, 2, 3];\narr.map(item => { // item为数组的元素\n    console.log(item); // 1, 2, 3\n    return item * 2; // 返回一个处理过的新数组[2, 4, 6]\n})\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。")]),this._v(" "),e("li",[this._v("map() 方法按照原始数组元素顺序依次处理元素。")]),this._v(" "),e("li",[this._v("这种方式也是用的比较广泛的，虽然用起来比较优雅，但实际效率还比不上forEach")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",{attrs:{start:"9"}},[e("li",[e("h3",{attrs:{id:"reduce"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#reduce","aria-hidden":"true"}},[this._v("#")]),this._v(" reduce()")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("reduce")]),this._v(" 可以将数组中的元素通过回调函数最终转换为一个值。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("const arr = [1, 2, 3]\nconst sum = arr.reduce((acc, current) => acc + current, 0)\nconsole.log(sum)\n")])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("对于 "),e("code",[this._v("reduce")]),this._v(" 来说，它接受两个参数，分别是回调函数和初始值。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("首先初始值为 0，该值会在执行第一次回调函数时作为第一个参数传入")]),this._v(" "),e("li",[this._v("回调函数接受四个参数，分别为累计值、当前元素、当前索引、原数组，后三者想必大家都可以明白作用，这里着重分析第一个参数")]),this._v(" "),e("li",[this._v("在一次执行回调函数时，当前值和初始值相加得出结果 1，该结果会在第二次执行回调函数时当做第一个参数传入")]),this._v(" "),e("li",[this._v("所以在第二次执行回调函数时，相加的值就分别是 1 和 2，以此类推，循环结束后得到结果 6")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"如何解决回调地狱问题？"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何解决回调地狱问题？","aria-hidden":"true"}},[this._v("#")]),this._v(" 如何解决回调地狱问题？")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"回调函数引起调问题"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#回调函数引起调问题","aria-hidden":"true"}},[this._v("#")]),this._v(" 回调函数引起调问题")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身")]),this._v(" "),e("li",[this._v("嵌套函数一多，就很难处理错误")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"解决回调地狱的方法"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#解决回调地狱的方法","aria-hidden":"true"}},[this._v("#")]),this._v(" 解决回调地狱的方法")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",[e("li",[this._v("Generator")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[e("code",[this._v("Generator")]),this._v(" 最大的特点就是可以控制函数的执行")])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("用得少，而且绕")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",{attrs:{start:"2"}},[e("li",[this._v("Promise")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("等待中 (pending)")]),this._v(" "),e("li",[this._v("完成了 (resolved)")]),this._v(" "),e("li",[this._v("拒绝了 (rejected)")])])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("p",[s("code",[t._v("Promise")]),t._v(" 实现了链式调用，也就是说每次调用 "),s("code",[t._v("then")]),t._v(" 之后返回的都是一个 "),s("code",[t._v("Promise")]),t._v(" ，并且是一个全新的 "),s("code",[t._v("Promise")]),t._v(" ，原因也是因为状态不可变。如果你在 "),s("code",[t._v("then")]),t._v(" 中 使用了 "),s("code",[t._v("return")]),t._v(" ，那么 "),s("code",[t._v("return")]),t._v(" 的值会被 "),s("code",[t._v("Promise.resolve()")]),t._v(" 包装")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",{attrs:{start:"3"}},[e("li",[this._v("async 及 await")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("对比 "),e("code",[this._v("Promise")]),this._v(" 的优点")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("优势在于处理 then 的调用链，能够更清晰准确的写出代码，毕竟写一大堆 then 也很恶心，并且也能优雅地解决回调地狱问题")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("因为 "),e("code",[this._v("await")]),this._v(" 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 "),e("code",[this._v("await")]),this._v(" 会导致性能上的降低")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"event-loop"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#event-loop","aria-hidden":"true"}},[this._v("#")]),this._v(" event loop")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"js单线程好处"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#js单线程好处","aria-hidden":"true"}},[this._v("#")]),this._v(" js单线程好处")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"异步代码执行顺序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#异步代码执行顺序","aria-hidden":"true"}},[this._v("#")]),this._v(" 异步代码执行顺序")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h4",{attrs:{id:"event-loop-执行顺序"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#event-loop-执行顺序","aria-hidden":"true"}},[this._v("#")]),this._v(" event loop 执行顺序")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",[e("li",[this._v("首先执行同步代码，这属于宏任务")]),this._v(" "),e("li",[this._v("当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行")]),this._v(" "),e("li",[this._v("执行所有微任务")]),this._v(" "),e("li",[this._v("当执行完所有微任务后，如有必要会渲染页面")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("微任务包括 process.nextTick ，promise ，MutationObserver，其中 process.nextTick 为 Node 独有。")]),this._v(" "),e("li",[this._v("宏任务包括 script ， setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"call-apply-bind"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#call-apply-bind","aria-hidden":"true"}},[this._v("#")]),this._v(" call, apply, bind")])},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("ul",[s("li",[s("p",[s("code",[t._v("apply")]),t._v(" 和 "),s("code",[t._v("call")]),t._v(": apply 和 call 的用法几乎相同, 唯一的差别在于：当函数需要传递多个变量时, apply 可以接受一个数组作为参数输入, call 则是接受一系列的单独变量。")])]),t._v(" "),s("li",[s("p",[s("code",[t._v("bind")]),t._v(": 和call很相似，第一个参数是this的指向，从第二个参数开始是接收的参数列表。区别在于bind方法返回值是函数。")])]),t._v(" "),s("li",[s("p",[t._v("在 ES6 的箭头函数下, call 和 apply 将失效:")]),t._v(" "),s("ul",[s("li",[t._v("箭头函数体内的 this 对象, 就是定义时所在的对象, 而不是使用时所在的对象;所以不需要类似于var _this = this这种丑陋的写法\n箭头函数不可以当作构造函数，也就是说不可以使用 new 命令。")]),t._v(" "),s("li",[t._v("箭头函数不可以使用 arguments 对象,，该对象在函数体内不存在。")])])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"垃圾回收机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收机制","aria-hidden":"true"}},[this._v("#")]),this._v(" 垃圾回收机制")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"概念"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#概念","aria-hidden":"true"}},[this._v("#")]),this._v(" 概念:")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ul",[e("li",[this._v("标记清除: 当进入作用域时，进行标记，离开作用域时，标记并回收这些变量")]),this._v(" "),e("li",[this._v("引用计数是跟踪记录每个值被引用的次数。就是变量的引用次数，被引用一次则加1，当这个引用计数为0时，被视为准备回收的对象，每当过一段时间开始垃圾回收的时候，就把被引用数为0的变量回收。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"内存泄漏"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内存泄漏","aria-hidden":"true"}},[this._v("#")]),this._v(" 内存泄漏")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",[e("li",[this._v("全局变量引起的内存泄露")]),this._v(" "),e("li",[this._v("闭包引起的内存泄露：慎用闭包")]),this._v(" "),e("li",[this._v("dom清空或删除时，事件未清除导致的内存泄漏")]),this._v(" "),e("li",[this._v("循环引用带来的内存泄露")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"如何减少垃圾回收开销"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#如何减少垃圾回收开销","aria-hidden":"true"}},[this._v("#")]),this._v(" 如何减少垃圾回收开销")])},function(){var t=this.$createElement,e=this._self._c||t;return e("ol",[e("li",[this._v("在对象结束使用后 ，令obj = null。这样利于解除循环引用，使得无用变量及时被回收；")]),this._v(" "),e("li",[this._v("js中开辟空间的操作有new(), [ ], { }, function (){..}。最大限度的实现对象的重用；")]),this._v(" "),e("li",[this._v("慎用闭包。闭包容易引起内存泄露。本来在函数返回之后，之前的空间都会被回收。但是由于闭包可能保存着函数内部变量的引用，且闭包在外部环境，就会导致函数内部的变量不能够销毁。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"节流和防抖"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#节流和防抖","aria-hidden":"true"}},[this._v("#")]),this._v(" 节流和防抖")])},function(){var t=this.$createElement,e=this._self._c||t;return e("h3",{attrs:{id:"节流"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#节流","aria-hidden":"true"}},[this._v("#")]),this._v(" 节流")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("考虑一个场景，滚动事件中会发起网络请求，但是我们并不希望用户在滚动过程中一直发起请求，而是"),e("strong",[this._v("隔一段时间发起一次")]),this._v("，对于这种情况我们就可以使用节流。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("节流:  在某段时间内，不管你触发了多少次回调，我都只认第一次，并在计时结束时给予响应。")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v('function log(){\n    console.log(\'打印了\')\n}\n\n// 节流\nfunction jieliu(fn, delay){\n    let canDo = 1;\n   return function (){\n    if(canDo){\n        fn()\n        canDo = 0;\n        setTimeout(() =>{\n            canDo = 1;\n        }, delay) \n    } else {\n        return\n    }\n   }  \n}\n\n// 调用\nvar body = document.querySelector("body");\nbody.addEventListener("scoll", function(){\n    jieliu(log, 2000)\n})\n')])])])},function(){var t=this.$createElement,e=this._self._c||t;return e("h2",{attrs:{id:"防抖"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#防抖","aria-hidden":"true"}},[this._v("#")]),this._v(" #防抖")])},function(){var t=this.$createElement,e=this._self._c||t;return e("p",[this._v("考虑一个场景，有一个按钮点击会触发网络请求，但是我们并不希望每次点击都发起网络请求，而是当用户点击按钮"),e("strong",[this._v("一段时间后没有再次点击")]),this._v("的情况才去发起网络请求，对于这种情况我们就可以使用防抖。")])},function(){var t=this.$createElement,e=this._self._c||t;return e("blockquote",[e("p",[this._v("防抖:  我会等你到底。在某段时间内，不管你触发了多少次回调，我都只认最后一次")])])},function(){var t=this.$createElement,e=this._self._c||t;return e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[this._v("function fangdou(fn, delay){\n    let timer = null;\n    return function() {\n        if(timer){\n            clearTimeout(timer)\n        }\n        timer = setTimeout(()=>{\n            fn()\n        }, delay)\n    }\n}\n")])])])}],i=s(0),a=Object(i.a)({},function(){var t=this,e=t.$createElement,s=t._self._c||e;return s("div",{staticClass:"content"},[t._m(0),t._v(" "),t._m(1),t._v(" "),t._m(2),t._v(" "),t._m(3),t._v(" "),t._m(4),t._v(" "),t._m(5),t._v(" "),t._m(6),t._v(" "),t._m(7),t._v(" "),t._m(8),t._v(" "),t._m(9),t._v(" "),t._m(10),t._v(" "),t._m(11),t._v(" "),t._m(12),t._v(" "),t._m(13),t._v(" "),t._m(14),t._v(" "),t._m(15),t._m(16),t._v(" "),t._m(17),t._v(" "),t._m(18),t._v(" "),t._m(19),t._m(20),t._v(" "),t._m(21),t._v(" "),t._m(22),s("p",[t._v("首先箭头函数其实是没有 this 的，箭头函数中的 this 只取决包裹箭头函数的第一个普通函数的 this。在这个例子中，因为包裹箭头函数的第一个普通函数是 a，所以此时的 this 是 window。另外对箭头函数使用 bind 这类函数是无效的。\nå\n最后种情况也就是 bind 这些改变上下文的 API 了，对于这些函数来说，this 取决于第一个参数，如果第一个参数为空，那么就是 window。")]),t._v(" "),s("p",[t._v("如果对一个函数进行多次 bind，那么上下文会是什么呢？")]),t._v(" "),t._m(23),s("p",[t._v("不管我们给函数 bind 几次，fn 中的 this 永远由第一次 bind 决定")]),t._v(" "),t._m(24),t._v(" "),s("p",[t._v("首先，new 的方式优先级最高，接下来是 bind 这些函数，然后是 obj.foo() 这种调用方式，最后是 foo 这种调用方式，同时，箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。")]),t._v(" "),t._m(25),t._v(" "),t._m(26),t._v(" "),t._m(27),t._v(" "),s("p",[t._v("闭包就是指有权访问另一个函数作用域中的变量的函数。外部函数调用之后其变量对象本应该被销毁，但闭包的存在使我们仍然可以访问外部函数的变量对象")]),t._v(" "),t._m(28),t._m(29),t._v(" "),t._m(30),t._v(" "),t._m(31),t._v(" "),t._m(32),t._v(" "),t._m(33),t._v(" "),t._m(34),t._v(" "),t._m(35),t._v(" "),t._m(36),t._v(" "),t._m(37),t._v(" "),t._m(38),t._v(" "),t._m(39),t._v(" "),t._m(40),t._m(41),s("p",[t._v("需要深拷贝推荐使用 "),s("a",{attrs:{href:"https://lodash.com/docs/4.17.15#cloneDeep",target:"_blank",rel:"noopener noreferrer"}},[t._v(" lodash 的深拷贝函数"),s("OutboundLink")],1)]),t._v(" "),t._m(42),t._v(" "),t._m(43),t._v(" "),t._m(44),t._v(" "),t._m(45),t._v(" "),t._m(46),t._v(" "),t._m(47),t._v(" "),t._m(48),t._v(" "),t._m(49),t._m(50),t._v(" "),t._m(51),t._v(" "),t._m(52),t._v(" "),t._m(53),t._v(" "),t._m(54),t._v(" "),t._m(55),t._v(" "),t._m(56),t._v(" "),s("p",[t._v("在早期，使用立即执行函数实现模块化是常见的手段，通过函数作用域解决了命名冲突、污染全局作用域的问题。")]),t._v(" "),t._m(57),t._m(58),t._v(" "),t._m(59),t._m(60),t._v(" "),t._m(61),t._m(62),t._v(" "),t._m(63),t._m(64),t._v(" "),t._m(65),t._v(" "),t._m(66),t._m(67),t._v(" "),s("p",[t._v("Vue 中的响应式，需要我们在 get 中收集依赖，在 set 派发更新，之所以 Vue3.0 要使用 Proxy 替换原本的 API 原因在于 Proxy 无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是 Proxy 可以完美监听到任何方式的数据改变，唯一缺陷可能就是浏览器的兼容性不好了。")]),t._v(" "),t._m(68),t._v(" "),s("p",[t._v("1.### 普通for循环")]),t._v(" "),t._m(69),t._m(70),t._v(" "),t._m(71),s("p",[t._v("使用临时变量，将长度缓存起来，避免重复获取数组长度，当数组较大时优化效果才会比较明显。这种方法基本上是所有循环遍历方法中性能最高的一种，并且这一类型的for循环可以通过用break来中断循环。")]),t._v(" "),t._m(72),t._v(" "),t._m(73),t._m(74),t._v(" "),t._m(75),t._v(" "),t._m(76),t._m(77),t._v(" "),t._m(78),t._v(" "),t._m(79),t._m(80),t._v(" "),t._m(81),t._v(" "),t._m(82),t._m(83),t._v(" "),t._m(84),t._v(" "),t._m(85),t._m(86),t._v(" "),t._m(87),t._v(" "),t._m(88),t._m(89),t._v(" "),t._m(90),t._v(" "),t._m(91),t._v(" "),t._m(92),t._m(93),t._v(" "),s("p",[t._v("reduce 过程")]),t._v(" "),t._m(94),t._v(" "),t._m(95),t._v(" "),t._m(96),t._v(" "),t._m(97),t._v(" "),t._m(98),t._v(" "),t._m(99),t._v(" "),t._m(100),t._v(" "),t._m(101),t._v(" "),t._m(102),t._v(" "),s("p",[t._v("三种状态")]),t._v(" "),t._m(103),t._v(" "),s("p",[t._v("这个承诺一旦从等待状态变成为其他状态就永远不能更改状态了，也就是说一旦状态变为 resolved 后，就不能再次改变。")]),t._v(" "),t._m(104),t._v(" "),t._m(105),t._v(" "),s("p",[t._v("之前写的一篇"),s("a",{attrs:{href:"https://juejin.im/post/5d89e9e1f265da03a049b982",target:"_blank",rel:"noopener noreferrer"}},[t._v("《async/await》"),s("OutboundLink")],1)]),t._v(" "),t._m(106),t._v(" "),t._m(107),t._v(" "),s("p",[t._v("缺点:")]),t._v(" "),t._m(108),t._v(" "),t._m(109),t._v(" "),t._m(110),t._v(" "),s("p",[t._v("JS 可以修改 DOM，如果在 JS 执行的时候 UI 线程还在工作，就可能导致不能安全的渲染 UI。")]),t._v(" "),t._m(111),t._v(" "),t._m(112),t._v(" "),t._m(113),t._v(" "),s("p",[t._v("然5. 后开始下一轮 Event Loop，执行宏任务中的异步代码，也就是 setTimeout 中的回调函数")]),t._v(" "),t._m(114),t._v(" "),t._m(115),t._v(" "),s("p",[t._v("作用: call、apply、bind的作用是改变函数运行时this的指向。")]),t._v(" "),t._m(116),t._v(" "),t._m(117),t._v(" "),t._m(118),t._v(" "),s("p",[t._v("垃圾回收机制(GC:Garbage Collection),执行环境负责管理代码执行过程中使用的内存。垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。")]),t._v(" "),s("p",[t._v("垃圾回收策略:")]),t._v(" "),s("p",[t._v("2种最为常用：标记清除和引用计数，其中标记清除更为常用。")]),t._v(" "),t._m(119),t._v(" "),t._m(120),t._v(" "),s("p",[t._v("引起内存泄漏原因主要有:")]),t._v(" "),t._m(121),t._v(" "),t._m(122),t._v(" "),t._m(123),t._v(" "),t._m(124),t._v(" "),t._m(125),t._v(" "),t._m(126),t._v(" "),t._m(127),t._v(" "),t._m(128),t._m(129),t._v(" "),t._m(130),t._v(" "),t._m(131),t._v(" "),t._m(132)])},r,!1,null,null,null);e.default=a.exports}}]);