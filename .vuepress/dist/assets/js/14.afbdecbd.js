(window.webpackJsonp=window.webpackJsonp||[]).push([[14],{173:function(a,e,t){"use strict";t.r(e);var n=t(0),r=Object(n.a)({},function(){this.$createElement;this._self._c;return this._m(0)},[function(){var a=this,e=a.$createElement,t=a._self._c||e;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"webpack-知识"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#webpack-知识","aria-hidden":"true"}},[a._v("#")]),a._v(" webpack 知识")]),a._v(" "),t("h2",{attrs:{id:"减少-webpack-打包时间"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#减少-webpack-打包时间","aria-hidden":"true"}},[a._v("#")]),a._v(" 减少 webpack 打包时间")]),a._v(" "),t("ol",[t("li",[t("p",[a._v("优化 loader\n优化 Loader 的文件搜索范围")])]),a._v(" "),t("li",[t("p",[a._v("HappyPack (插件)\nHappyPack 可以将 Loader 的同步执行转换为并行的，这样就能充分利用系统资源来加快打包效率")])]),a._v(" "),t("li",[t("p",[a._v("DllPlugin (插件)\nDllPlugin 可以将特定的类库提前打包然后引入。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。")])]),a._v(" "),t("li",[t("p",[a._v("代码压缩\nWebpack4 中，我们就不需要以上这些操作了，只需要将 mode 设置为 production 就可以默认开启以上功能")])])]),a._v(" "),t("h2",{attrs:{id:"减小-webpack-打包后的体积"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#减小-webpack-打包后的体积","aria-hidden":"true"}},[a._v("#")]),a._v(" 减小 webpack 打包后的体积")]),a._v(" "),t("ol",[t("li",[a._v("Scope Hoisting\nScope Hoisting 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去")])]),a._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[a._v("// webpack4 只需这样配置\nmodule.exports = {\n  optimization: {\n    concatenateModules: true\n  }\n}\n")])])]),t("ol",{attrs:{start:"2"}},[t("li",[a._v("Tree Shaking\nTree Shaking 可以实现删除项目中未被引用的代码, 如果你使用 Webpack 4 的话，开启生产环境就会自动启动这个优化功能。")])])])}],!1,null,null,null);e.default=r.exports}}]);