<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JS基础 | 虎皮猫的博客</title>
    <meta name="description" content="个人博客-wxw">
    
    
    <link rel="preload" href="/blog/assets/css/0.styles.583a6a78.css" as="style"><link rel="preload" href="/blog/assets/js/app.7cc8aca2.js" as="script"><link rel="preload" href="/blog/assets/js/3.52bd1b81.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.fb3f107b.js"><link rel="prefetch" href="/blog/assets/js/11.2fb24d1c.js"><link rel="prefetch" href="/blog/assets/js/12.80d4bbdf.js"><link rel="prefetch" href="/blog/assets/js/13.f4224636.js"><link rel="prefetch" href="/blog/assets/js/14.afbdecbd.js"><link rel="prefetch" href="/blog/assets/js/15.8de5b498.js"><link rel="prefetch" href="/blog/assets/js/2.a9f2a1df.js"><link rel="prefetch" href="/blog/assets/js/4.3d8207ce.js"><link rel="prefetch" href="/blog/assets/js/5.5d714c47.js"><link rel="prefetch" href="/blog/assets/js/6.77f88835.js"><link rel="prefetch" href="/blog/assets/js/7.c4bcbe9f.js"><link rel="prefetch" href="/blog/assets/js/8.15834562.js"><link rel="prefetch" href="/blog/assets/js/9.23bf0e30.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.583a6a78.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">虎皮猫的博客</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="https://github.com/wxw007/learning-note" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="https://github.com/wxw007/learning-note" target="_blank" rel="noopener noreferrer" class="nav-link external">
  github
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/blog/html.html" class="sidebar-link">HTML 基础</a></li><li><a href="/blog/css.html" class="sidebar-link">CSS 基础</a></li><li><a href="/blog/js.html" class="active sidebar-link">JS基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/js.html#js数据数据类型" class="sidebar-link">js数据数据类型</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#判断数据类型" class="sidebar-link">判断数据类型</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#this" class="sidebar-link">this</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/js.html#普通函数" class="sidebar-link">普通函数</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#箭头函数" class="sidebar-link">箭头函数</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#this的优先级" class="sidebar-link">this的优先级</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/js.html#闭包" class="sidebar-link">闭包</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/js.html#什么是闭包？" class="sidebar-link">什么是闭包？</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#闭包的使用场景" class="sidebar-link">闭包的使用场景</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#使用闭包的注意事项" class="sidebar-link">使用闭包的注意事项</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/js.html#浅拷贝、深拷贝" class="sidebar-link">浅拷贝、深拷贝</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/js.html#浅拷贝" class="sidebar-link">浅拷贝</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#深拷贝" class="sidebar-link">深拷贝</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/js.html#原型和原型链" class="sidebar-link">原型和原型链</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/js.html#原型" class="sidebar-link">原型</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#原型链" class="sidebar-link">原型链</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#new-运算符做了什么" class="sidebar-link">new 运算符做了什么</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/js.html#var、let、const-区别" class="sidebar-link">var、let、const 区别</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#模块化" class="sidebar-link">模块化</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/js.html#模块化的好处" class="sidebar-link">模块化的好处</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#模块化的方式" class="sidebar-link">模块化的方式</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/js.html#proxy" class="sidebar-link">Proxy</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#数组遍历方法" class="sidebar-link">数组遍历方法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/js.html#优化的-for-循环" class="sidebar-link">优化的 for 循环</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#for-of-遍历-这种遍历支持es6" class="sidebar-link">for...of...遍历(这种遍历支持ES6)</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#foreach" class="sidebar-link">forEach()</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#some" class="sidebar-link">some()</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#every" class="sidebar-link">every()</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#filter" class="sidebar-link">filter()</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#map" class="sidebar-link">map()</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#reduce" class="sidebar-link">reduce()</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/js.html#如何解决回调地狱问题？" class="sidebar-link">如何解决回调地狱问题？</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/js.html#回调函数引起调问题" class="sidebar-link">回调函数引起调问题</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#解决回调地狱的方法" class="sidebar-link">解决回调地狱的方法</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/js.html#event-loop" class="sidebar-link">event loop</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/js.html#js单线程好处" class="sidebar-link">js单线程好处</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#异步代码执行顺序" class="sidebar-link">异步代码执行顺序</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/js.html#call-apply-bind" class="sidebar-link">call, apply, bind</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#垃圾回收机制" class="sidebar-link">垃圾回收机制</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/js.html#概念" class="sidebar-link">概念:</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#内存泄漏" class="sidebar-link">内存泄漏</a></li><li class="sidebar-sub-header"><a href="/blog/js.html#如何减少垃圾回收开销" class="sidebar-link">如何减少垃圾回收开销</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/js.html#节流和防抖" class="sidebar-link">节流和防抖</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/js.html#节流" class="sidebar-link">节流</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/js.html#防抖" class="sidebar-link">#防抖</a></li></ul></li><li><a href="/blog/algorithm.html" class="sidebar-link">JS算法</a></li><li><a href="/blog/vue.html" class="sidebar-link">vue</a></li><li><a href="/blog/brower.html" class="sidebar-link">浏览器相关</a></li><li><a href="/blog/webpack.html" class="sidebar-link">webpack 知识</a></li><li><a href="/blog/optimization.html" class="sidebar-link">性能优化</a></li><li><a href="/blog/git.html" class="sidebar-link">git 使用以及规范</a></li></ul> </div> <div class="page"> <div class="content"><h1 id="js基础"><a href="#js基础" aria-hidden="true" class="header-anchor">#</a> JS基础</h1> <h2 id="js数据数据类型"><a href="#js数据数据类型" aria-hidden="true" class="header-anchor">#</a> js数据数据类型</h2> <ol><li>原始类型 <strong>(6个)</strong></li></ol> <ul><li>boolean</li> <li>null</li> <li>undefined</li> <li>string</li> <li>number</li> <li>symbol</li></ul> <blockquote><p>原始类型都是按值传递</p></blockquote> <ol start="2"><li>引用类型</li></ol> <ul><li>object</li></ul> <h2 id="判断数据类型"><a href="#判断数据类型" aria-hidden="true" class="header-anchor">#</a> 判断数据类型</h2> <ul><li><code>typeof</code> 对于原始类型来说，除了 <code>null</code> 都可以显示正确的类型</li> <li><code>typeof</code> 对于对象来说，除了函数都会显示 <code>object</code> ，所以说 <code>typeof</code> 并不能准确判断变量到底是什么类型</li></ul> <blockquote><p><code>typeof</code> 只能判断原始类型</p></blockquote> <ul><li><code>instanceof</code> 用来判断A是否为B的实例，表达式为：A <code>instanceof</code> B，如果A是B的实例，则返回true，否则返回false。 <code>instanceof</code> 检测的是原型，内部机制是通过判断对象的原型链中是否有类型的原型。</li></ul> <blockquote><p><code>instanceof</code> 只能用来判断两个对象是否属于实例关系， 而不能判断一个对象实例具体属于哪种类型。</p></blockquote> <ul><li><code>constructor</code> : ' '.constructor === String</li></ul> <blockquote><p>null 和 undefined 无constructor，这种方法判断不了。 如果自定义对象，开发者重写prototype之后，原有的constructor会丢失。</p></blockquote> <ul><li><code>Object.prototype.toString()</code> toString()是Object的原型方法，调用该方法，默认返回当前对象的[[Class]]。这是一个内部属性，其格式为[object Xxx], 其中Xxx就是对象的类型。对于 <code>Object</code> 对象，直接调用toString()就能返回[object Object], 而对于其他对象，则需要通过call、apply来调用才能返回正确的类型信息。</li></ul> <div class="language- extra-class"><pre class="language-text"><code>Object.prototype.toString.call('') // [object String]
</code></pre></div><p><code>Object.prototype.toString()</code> 是最推荐的</p> <h2 id="this"><a href="#this" aria-hidden="true" class="header-anchor">#</a> this</h2> <h3 id="普通函数"><a href="#普通函数" aria-hidden="true" class="header-anchor">#</a> 普通函数</h3> <div class="language- extra-class"><pre class="language-text"><code>function foo() {
  console.log(this.a)
}
var a = 1
foo()

const obj = {
  a: 2,
  foo: foo
}
obj.foo()

const c = new foo()
</code></pre></div><ul><li>对于直接调用 foo 来说，不管 foo 函数被放在了什么地方，this 一定是 window</li> <li>对于 obj.foo() 来说，我们只需要记住，谁调用了函数，谁就是 this，所以在这个场景下 foo 函数中的 this 就是 obj 对象</li> <li>对于 new 的方式来说，this 被永远绑定在了 c 上面，不会被任何方式改变 this</li></ul> <h3 id="箭头函数"><a href="#箭头函数" aria-hidden="true" class="header-anchor">#</a> 箭头函数</h3> <div class="language- extra-class"><pre class="language-text"><code>function a() {
  return () =&gt; {
    return () =&gt; {
      console.log(this)
    }
  }
}
console.log(a()()())
</code></pre></div><p>首先箭头函数其实是没有 this 的，箭头函数中的 this 只取决包裹箭头函数的第一个普通函数的 this。在这个例子中，因为包裹箭头函数的第一个普通函数是 a，所以此时的 this 是 window。另外对箭头函数使用 bind 这类函数是无效的。
å
最后种情况也就是 bind 这些改变上下文的 API 了，对于这些函数来说，this 取决于第一个参数，如果第一个参数为空，那么就是 window。</p> <p>如果对一个函数进行多次 bind，那么上下文会是什么呢？</p> <div class="language- extra-class"><pre class="language-text"><code>let a = {}
let fn = function () { console.log(this) }
fn.bind().bind(a)() // =&gt; ?
</code></pre></div><p>不管我们给函数 bind 几次，fn 中的 this 永远由第一次 bind 决定</p> <h3 id="this的优先级"><a href="#this的优先级" aria-hidden="true" class="header-anchor">#</a> this的优先级</h3> <p>首先，new 的方式优先级最高，接下来是 bind 这些函数，然后是 obj.foo() 这种调用方式，最后是 foo 这种调用方式，同时，箭头函数的 this 一旦被绑定，就不会再被任何方式所改变。</p> <p><img src="/blog/assets/img/1.4fd85c39.jpg" alt="this流程图"></p> <h2 id="闭包"><a href="#闭包" aria-hidden="true" class="header-anchor">#</a> 闭包</h2> <h3 id="什么是闭包？"><a href="#什么是闭包？" aria-hidden="true" class="header-anchor">#</a> 什么是闭包？</h3> <p>闭包就是指有权访问另一个函数作用域中的变量的函数。外部函数调用之后其变量对象本应该被销毁，但闭包的存在使我们仍然可以访问外部函数的变量对象</p> <div class="language- extra-class"><pre class="language-text"><code>例子: 闭包实现一个函数，每次调用返回值加1
function a(){
    var n = 1;
    return function(){
       return n++
    }
}
var b = a()

b() // 1
b() // 2
b() // 3
</code></pre></div><h3 id="闭包的使用场景"><a href="#闭包的使用场景" aria-hidden="true" class="header-anchor">#</a> 闭包的使用场景</h3> <ol><li>实现私有成员。</li> <li>保护命名空间，避免污染全局变量。</li> <li>缓存变量。</li></ol> <blockquote><p>常见的用闭包解决循环打印数值一样的问题</p></blockquote> <h3 id="使用闭包的注意事项"><a href="#使用闭包的注意事项" aria-hidden="true" class="header-anchor">#</a> 使用闭包的注意事项</h3> <ol><li><strong>内存泄漏</strong> - 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题</li> <li>如果内部函数的变量和外部函数的变量名相同时，那么内部函数再也无法指向外部函数那个同名的变量</li></ol> <h2 id="浅拷贝、深拷贝"><a href="#浅拷贝、深拷贝" aria-hidden="true" class="header-anchor">#</a> 浅拷贝、深拷贝</h2> <h3 id="浅拷贝"><a href="#浅拷贝" aria-hidden="true" class="header-anchor">#</a> 浅拷贝</h3> <ol><li><code>Object.assign</code></li> <li>扩展运算符 <code>...</code></li></ol> <h3 id="深拷贝"><a href="#深拷贝" aria-hidden="true" class="header-anchor">#</a> 深拷贝</h3> <p>通常用转字符串的方法进行深拷贝 <code>JSON.parse(JSON.stringify(object))</code> 。
但是此方法存在局限性</p> <ul><li>会忽略 <code>undefined</code></li> <li>会忽略 <code>symbol</code></li> <li>不能序列化函数</li> <li>不能解决循环引用的对象</li></ul> <div class="language- extra-class"><pre class="language-text"><code>let obj = {
  a: 1,
  b: {
    c: 2,
    d: 3,
  },
}
obj.c = obj.b
obj.e = obj.a
obj.b.c = obj.c
obj.b.d = obj.b
obj.b.e = obj.b.c
let newObj = JSON.parse(JSON.stringify(obj))
console.log(newObj)  //报错
</code></pre></div><div class="language- extra-class"><pre class="language-text"><code>let a = {
  age: undefined,
  sex: Symbol('male'),
  jobs: function() {},
  name: 'yck'
}
let b = JSON.parse(JSON.stringify(a))
console.log(b) // {name: &quot;yck&quot;} 只剩下name
</code></pre></div><p>需要深拷贝推荐使用 <a href="https://lodash.com/docs/4.17.15#cloneDeep" target="_blank" rel="noopener noreferrer"> lodash 的深拷贝函数<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="原型和原型链"><a href="#原型和原型链" aria-hidden="true" class="header-anchor">#</a> 原型和原型链</h2> <h3 id="原型"><a href="#原型" aria-hidden="true" class="header-anchor">#</a> 原型</h3> <p>每个 JS 对象都有 <code>__proto__</code> 属性，这个属性指向了原型，实例的 <code>__proto__</code> 属性(原型) 等于其构造函数的 <code>prototype</code> 。</p> <h3 id="原型链"><a href="#原型链" aria-hidden="true" class="header-anchor">#</a> 原型链</h3> <p>对象的 <code>__proto__</code> 属性指向原型， <code>__proto__</code> 将对象和原型连接起来组成了原型链。</p> <p>当在一个对象 obj 上访问某个属性时，如果不存在于 obj，那么便会去对象的原型也就是 <code>obj.__proto__</code> 上去找这个属性。如果有则返回这个属性，没有则去对象 obj 的原型的原型也就是 <code>obj.__proto__.__proto__</code> 去找，重复以上步骤。一直到访问纯对象的原型的原型 <code>{}.__proto.__proto__</code> ，也就是 <code>null</code> ，直接返回 <code>undefined</code> 。</p> <h3 id="new-运算符做了什么"><a href="#new-运算符做了什么" aria-hidden="true" class="header-anchor">#</a> new 运算符做了什么</h3> <div class="language- extra-class"><pre class="language-text"><code>function F(){
  console.log('这是构造函数')
}

// new 做了以下四步
var obj = {}; // 1. 创建一个空对象 obj
obj.__proto__ = F.prototype; // 2. 将空对象的 __proto__ 指向F函数对象的prototype对象
F.call(obj); // 3. 将F函数的 this 指向 obj, 并执行 F
return obj; // 返回 obj

// 自己实现一个 new 方法 
function myNew(){
  var obj = {}; // 1. 创建一个空对象 obj
  var Constructor = [].shift.call(arguments) //2. 获取构造函数
  obj.__proto__ = Constructor.prototype; //3. 将空对象的 __proto__ 指向构造函数的prototype对象
  var result = Constructor.apply(obj, arguments); //4. 将 this 指向 obj, 并执行Constructor函数
  return typeof result === &quot;object&quot; ? result : obj;//5. 如果返回值是一个对象就返回该对象，否则返回构造函数的一个实例对象
}
</code></pre></div><h2 id="var、let、const-区别"><a href="#var、let、const-区别" aria-hidden="true" class="header-anchor">#</a> var、let、const 区别</h2> <ul><li>函数提升优先于变量提升，函数提升会把整个函数挪到作用域顶部，变量提升只会把声明挪到作用域顶部。</li> <li>var 存在提升，我们能在声明之前使用。let、const 因为暂时性死区的原因，不能在声明前使用。</li> <li>var 在全局作用域下声明变量会导致变量挂载在 window 上，其他两者不会。</li> <li>let 和 const 作用基本一致，但是后者声明的变量不能再次赋值。</li></ul> <h2 id="模块化"><a href="#模块化" aria-hidden="true" class="header-anchor">#</a> 模块化</h2> <h3 id="模块化的好处"><a href="#模块化的好处" aria-hidden="true" class="header-anchor">#</a> 模块化的好处</h3> <ul><li>解决命名冲突</li> <li>提供复用性</li> <li>提高代码可维护性</li></ul> <h3 id="模块化的方式"><a href="#模块化的方式" aria-hidden="true" class="header-anchor">#</a> 模块化的方式</h3> <ol><li>立即执行函数</li></ol> <p>在早期，使用立即执行函数实现模块化是常见的手段，通过函数作用域解决了命名冲突、污染全局作用域的问题。</p> <div class="language- extra-class"><pre class="language-text"><code>(function(globalVariable){
   globalVariable.test = function() {}
   // ... 声明各种变量、函数都不会污染全局作用域
})(globalVariable)
</code></pre></div><ol start="2"><li>AMD和CMD (现已比较少使用)</li></ol> <div class="language- extra-class"><pre class="language-text"><code>// AMD
define(['./a', './b'], function(a, b) {
  // 加载模块完毕可以使用
  a.do()
  b.do()
})
// CMD
define(function(require, exports, module) {
  // 加载模块
  // 可以把 require 写在函数体的任意地方实现延迟加载
  var a = require('./a')
  a.doSomething()
})
</code></pre></div><ol start="3"><li>CommonJS</li></ol> <div class="language- extra-class"><pre class="language-text"><code>// a.js
module.exports = {
    a: 1
}
// or 
exports.a = 1

// b.js
var module = require('./a.js')
module.a // -&gt; log 1
</code></pre></div><ol start="4"><li>ES Module</li></ol> <div class="language- extra-class"><pre class="language-text"><code>// 引入模块 API
import XXX from './a.js'
import { XXX } from './a.js'
// 导出模块 API
export function a() {}
export default function() {}
</code></pre></div><h2 id="proxy"><a href="#proxy" aria-hidden="true" class="header-anchor">#</a> Proxy</h2> <p>Vue3.0 中将会通过 <code>Proxy</code> 来替换原本的 <code>Object.defineProperty</code> 来实现数据响应式。</p> <div class="language- extra-class"><pre class="language-text"><code>let p = new Proxy(target, handler)
</code></pre></div><p><code>target</code> 代表需要添加代理的对象， <code>handler</code> 用来自定义对象中的操作，比如可以用来自定义 <code>set</code> 或者 <code>get</code> 函数。</p> <p>Vue 中的响应式，需要我们在 get 中收集依赖，在 set 派发更新，之所以 Vue3.0 要使用 Proxy 替换原本的 API 原因在于 Proxy 无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是 Proxy 可以完美监听到任何方式的数据改变，唯一缺陷可能就是浏览器的兼容性不好了。</p> <h2 id="数组遍历方法"><a href="#数组遍历方法" aria-hidden="true" class="header-anchor">#</a> 数组遍历方法</h2> <p>1.### 普通for循环</p> <div class="language- extra-class"><pre class="language-text"><code>var arr = [1, 2, 3]
for(var i = 0; i &lt; arr.length; i++) { // 这里的i是代表数组的下标
    console.log(i); // 0, 1, 2
};
</code></pre></div><ol start="2"><li><h3 id="优化的-for-循环"><a href="#优化的-for-循环" aria-hidden="true" class="header-anchor">#</a> 优化的 for 循环</h3></li></ol> <div class="language- extra-class"><pre class="language-text"><code>var arr = [1, 2, 3]
for(var i = 0, len = arr.length; i &lt; len; i++) { // 这里的i是代表数组的下标
console.log(i); // 0, 1, 2 };　
</code></pre></div><p>使用临时变量，将长度缓存起来，避免重复获取数组长度，当数组较大时优化效果才会比较明显。这种方法基本上是所有循环遍历方法中性能最高的一种，并且这一类型的for循环可以通过用break来中断循环。</p> <ol start="3"><li><h3 id="for-of-遍历-这种遍历支持es6"><a href="#for-of-遍历-这种遍历支持es6" aria-hidden="true" class="header-anchor">#</a> for...of...遍历(这种遍历支持ES6)</h3></li></ol> <div class="language- extra-class"><pre class="language-text"><code>var arr = [1, 2, 3]
for(var item of arr) { // item代表数组里面的元素
    console.log(item); // 1, 2, 3
};　
</code></pre></div><ul><li><p>这是最简洁、最直接的遍历数组元素的语法</p></li> <li><p>这个方法避开了for-in循环的所有缺陷</p></li> <li><p>与forEach()不同的是，它可以正确响应break、continue和return语句</p></li> <li><p>性能要好于forin，但仍然比不上普通for循环</p></li></ul> <ol start="4"><li><h3 id="foreach"><a href="#foreach" aria-hidden="true" class="header-anchor">#</a> forEach()</h3></li></ol> <div class="language- extra-class"><pre class="language-text"><code>var arr = [1, 2, 3];
arr.forEach((item, index, arr) =&gt; { // item为arr的元素，index为下标，arr原数组
    console.log(item); // 1, 2, 3
    console.log(index); // 0, 1, 2
    console.log(arr); // [1, 2, 3]
});
</code></pre></div><p>这种遍历便捷还是挺便捷的，看起来优雅，对目标数组的操作很人性化，要元素给元素，要下标给下标，但是当某种情况你想<strong>中断遍历</strong>的时候，你就会感觉它就像鸡肋，食之无味，弃之可惜。由于foreach是Array型自带的，对于一些非这种类型的，无法直接使用(如NodeList)，所以才有了这个变种，使用这个变种可以让类似的数组拥有foreach功能。而且forEach的性能也会比普通的for循环弱。又下面的例子我们可以看到，我们常用的return false是可以终止代码继续往下执行的，但是在forEach遍历中，<strong>并没有终止循环</strong>，所以在用forEach的时候，要考虑使用场景了。</p> <ol start="5"><li><h3 id="some"><a href="#some" aria-hidden="true" class="header-anchor">#</a> some()</h3></li></ol> <div class="language- extra-class"><pre class="language-text"><code>var arr = [1, 2, 3];
arr.some((item, index, arr) =&gt; { // item为数组中的元素，index为下标，arr为目标数组
    console.log(item); // 1, 2, 3
    console.log(index); // 0, 1, 2
    console.log(arr); // [1, 2, 3]  
})
</code></pre></div><ul><li><p>some作为一个用来检测数组是否满足一些条件的函数存在，同样是可以用作遍历的函数签名同forEach，有区别的是当任一callback返回值匹配为true则会直接返回true，如果所有的callback匹配均为false，则返回false。</p></li> <li><p>some() 方法会依次执行数组的每个元素：</p></li> <li><p>如果有一个元素满足条件，则表达式返回true , 剩余的元素不会再执行检测。</p></li> <li><p>如果没有满足条件的元素，则返回false。</p></li></ul> <ol start="6"><li><h3 id="every"><a href="#every" aria-hidden="true" class="header-anchor">#</a> every()</h3></li></ol> <div class="language- extra-class"><pre class="language-text"><code>var arr = [1, 2, 3];
arr.every((item, index, arr) =&gt; { // item为数组中的元素，index为下标，arr为目标数组
    return item &gt; 0; // true
    return index == 0; // false
})
</code></pre></div><ul><li>every() 方法用于检测数组所有元素是否都符合指定条件（通过函数提供）。</li> <li>every() 方法使用指定函数检测数组中的所有元素：</li> <li>如果数组中检测到有一个元素不满足，则整个表达式返回 false ，且剩余的元素不会再进行检测。</li> <li>如果所有元素都满足条件，则返回 true。</li></ul> <ol start="7"><li><h3 id="filter"><a href="#filter" aria-hidden="true" class="header-anchor">#</a> filter()</h3></li></ol> <div class="language- extra-class"><pre class="language-text"><code>var arr = [1, 2, 3];
arr.filter(item =&gt; { // item为数组当前的元素
    return item &gt; 1; // [2, 3]
})
</code></pre></div><ul><li>filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素。</li></ul> <ol start="8"><li><h3 id="map"><a href="#map" aria-hidden="true" class="header-anchor">#</a> map()</h3></li></ol> <div class="language- extra-class"><pre class="language-text"><code>var arr = [1, 2, 3];
arr.map(item =&gt; { // item为数组的元素
    console.log(item); // 1, 2, 3
    return item * 2; // 返回一个处理过的新数组[2, 4, 6]
})
</code></pre></div><ul><li>map() 方法返回一个新数组，数组中的元素为原始数组元素调用函数处理后的值。</li> <li>map() 方法按照原始数组元素顺序依次处理元素。</li> <li>这种方式也是用的比较广泛的，虽然用起来比较优雅，但实际效率还比不上forEach</li></ul> <ol start="9"><li><h3 id="reduce"><a href="#reduce" aria-hidden="true" class="header-anchor">#</a> reduce()</h3></li></ol> <p><code>reduce</code> 可以将数组中的元素通过回调函数最终转换为一个值。</p> <div class="language- extra-class"><pre class="language-text"><code>const arr = [1, 2, 3]
const sum = arr.reduce((acc, current) =&gt; acc + current, 0)
console.log(sum)
</code></pre></div><p>对于 <code>reduce</code> 来说，它接受两个参数，分别是回调函数和初始值。</p> <p>reduce 过程</p> <ul><li>首先初始值为 0，该值会在执行第一次回调函数时作为第一个参数传入</li> <li>回调函数接受四个参数，分别为累计值、当前元素、当前索引、原数组，后三者想必大家都可以明白作用，这里着重分析第一个参数</li> <li>在一次执行回调函数时，当前值和初始值相加得出结果 1，该结果会在第二次执行回调函数时当做第一个参数传入</li> <li>所以在第二次执行回调函数时，相加的值就分别是 1 和 2，以此类推，循环结束后得到结果 6</li></ul> <h2 id="如何解决回调地狱问题？"><a href="#如何解决回调地狱问题？" aria-hidden="true" class="header-anchor">#</a> 如何解决回调地狱问题？</h2> <h3 id="回调函数引起调问题"><a href="#回调函数引起调问题" aria-hidden="true" class="header-anchor">#</a> 回调函数引起调问题</h3> <ul><li>嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身</li> <li>嵌套函数一多，就很难处理错误</li></ul> <h3 id="解决回调地狱的方法"><a href="#解决回调地狱的方法" aria-hidden="true" class="header-anchor">#</a> 解决回调地狱的方法</h3> <ol><li>Generator</li></ol> <p><code>Generator</code> 最大的特点就是可以控制函数的执行</p> <blockquote><p>用得少，而且绕</p></blockquote> <ol start="2"><li>Promise</li></ol> <p>三种状态</p> <ul><li>等待中 (pending)</li> <li>完成了 (resolved)</li> <li>拒绝了 (rejected)</li></ul> <p>这个承诺一旦从等待状态变成为其他状态就永远不能更改状态了，也就是说一旦状态变为 resolved 后，就不能再次改变。</p> <p><code>Promise</code> 实现了链式调用，也就是说每次调用 <code>then</code> 之后返回的都是一个 <code>Promise</code> ，并且是一个全新的 <code>Promise</code> ，原因也是因为状态不可变。如果你在 <code>then</code> 中 使用了 <code>return</code> ，那么 <code>return</code> 的值会被 <code>Promise.resolve()</code> 包装</p> <ol start="3"><li>async 及 await</li></ol> <p>之前写的一篇<a href="https://juejin.im/post/5d89e9e1f265da03a049b982" target="_blank" rel="noopener noreferrer">《async/await》<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>对比 <code>Promise</code> 的优点</p> <ul><li>优势在于处理 then 的调用链，能够更清晰准确的写出代码，毕竟写一大堆 then 也很恶心，并且也能优雅地解决回调地狱问题</li></ul> <p>缺点:</p> <ul><li>因为 <code>await</code> 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 <code>await</code> 会导致性能上的降低</li></ul> <h2 id="event-loop"><a href="#event-loop" aria-hidden="true" class="header-anchor">#</a> event loop</h2> <h3 id="js单线程好处"><a href="#js单线程好处" aria-hidden="true" class="header-anchor">#</a> js单线程好处</h3> <p>JS 可以修改 DOM，如果在 JS 执行的时候 UI 线程还在工作，就可能导致不能安全的渲染 UI。</p> <h3 id="异步代码执行顺序"><a href="#异步代码执行顺序" aria-hidden="true" class="header-anchor">#</a> 异步代码执行顺序</h3> <h4 id="event-loop-执行顺序"><a href="#event-loop-执行顺序" aria-hidden="true" class="header-anchor">#</a> event loop 执行顺序</h4> <ol><li>首先执行同步代码，这属于宏任务</li> <li>当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行</li> <li>执行所有微任务</li> <li>当执行完所有微任务后，如有必要会渲染页面</li></ol> <p>然5. 后开始下一轮 Event Loop，执行宏任务中的异步代码，也就是 setTimeout 中的回调函数</p> <ul><li>微任务包括 process.nextTick ，promise ，MutationObserver，其中 process.nextTick 为 Node 独有。</li> <li>宏任务包括 script ， setTimeout ，setInterval ，setImmediate ，I/O ，UI rendering。</li></ul> <h2 id="call-apply-bind"><a href="#call-apply-bind" aria-hidden="true" class="header-anchor">#</a> call, apply, bind</h2> <p>作用: call、apply、bind的作用是改变函数运行时this的指向。</p> <ul><li><p><code>apply</code> 和 <code>call</code>: apply 和 call 的用法几乎相同, 唯一的差别在于：当函数需要传递多个变量时, apply 可以接受一个数组作为参数输入, call 则是接受一系列的单独变量。</p></li> <li><p><code>bind</code>: 和call很相似，第一个参数是this的指向，从第二个参数开始是接收的参数列表。区别在于bind方法返回值是函数。</p></li> <li><p>在 ES6 的箭头函数下, call 和 apply 将失效:</p> <ul><li>箭头函数体内的 this 对象, 就是定义时所在的对象, 而不是使用时所在的对象;所以不需要类似于var _this = this这种丑陋的写法
箭头函数不可以当作构造函数，也就是说不可以使用 new 命令。</li> <li>箭头函数不可以使用 arguments 对象,，该对象在函数体内不存在。</li></ul></li></ul> <h2 id="垃圾回收机制"><a href="#垃圾回收机制" aria-hidden="true" class="header-anchor">#</a> 垃圾回收机制</h2> <h3 id="概念"><a href="#概念" aria-hidden="true" class="header-anchor">#</a> 概念:</h3> <p>垃圾回收机制(GC:Garbage Collection),执行环境负责管理代码执行过程中使用的内存。垃圾收集器会定期（周期性）找出那些不在继续使用的变量，然后释放其内存。但是这个过程不是实时的，因为其开销比较大，所以垃圾回收器会按照固定的时间间隔周期性的执行。</p> <p>垃圾回收策略:</p> <p>2种最为常用：标记清除和引用计数，其中标记清除更为常用。</p> <ul><li>标记清除: 当进入作用域时，进行标记，离开作用域时，标记并回收这些变量</li> <li>引用计数是跟踪记录每个值被引用的次数。就是变量的引用次数，被引用一次则加1，当这个引用计数为0时，被视为准备回收的对象，每当过一段时间开始垃圾回收的时候，就把被引用数为0的变量回收。</li></ul> <h3 id="内存泄漏"><a href="#内存泄漏" aria-hidden="true" class="header-anchor">#</a> 内存泄漏</h3> <p>引起内存泄漏原因主要有:</p> <ol><li>全局变量引起的内存泄露</li> <li>闭包引起的内存泄露：慎用闭包</li> <li>dom清空或删除时，事件未清除导致的内存泄漏</li> <li>循环引用带来的内存泄露</li></ol> <h3 id="如何减少垃圾回收开销"><a href="#如何减少垃圾回收开销" aria-hidden="true" class="header-anchor">#</a> 如何减少垃圾回收开销</h3> <ol><li>在对象结束使用后 ，令obj = null。这样利于解除循环引用，使得无用变量及时被回收；</li> <li>js中开辟空间的操作有new(), [ ], { }, function (){..}。最大限度的实现对象的重用；</li> <li>慎用闭包。闭包容易引起内存泄露。本来在函数返回之后，之前的空间都会被回收。但是由于闭包可能保存着函数内部变量的引用，且闭包在外部环境，就会导致函数内部的变量不能够销毁。</li></ol> <h2 id="节流和防抖"><a href="#节流和防抖" aria-hidden="true" class="header-anchor">#</a> 节流和防抖</h2> <h3 id="节流"><a href="#节流" aria-hidden="true" class="header-anchor">#</a> 节流</h3> <p>考虑一个场景，滚动事件中会发起网络请求，但是我们并不希望用户在滚动过程中一直发起请求，而是<strong>隔一段时间发起一次</strong>，对于这种情况我们就可以使用节流。</p> <blockquote><p>节流:  在某段时间内，不管你触发了多少次回调，我都只认第一次，并在计时结束时给予响应。</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>function log(){
    console.log('打印了')
}

// 节流
function jieliu(fn, delay){
    let canDo = 1;
   return function (){
    if(canDo){
        fn()
        canDo = 0;
        setTimeout(() =&gt;{
            canDo = 1;
        }, delay) 
    } else {
        return
    }
   }  
}

// 调用
var body = document.querySelector(&quot;body&quot;);
body.addEventListener(&quot;scoll&quot;, function(){
    jieliu(log, 2000)
})
</code></pre></div><h2 id="防抖"><a href="#防抖" aria-hidden="true" class="header-anchor">#</a> #防抖</h2> <p>考虑一个场景，有一个按钮点击会触发网络请求，但是我们并不希望每次点击都发起网络请求，而是当用户点击按钮<strong>一段时间后没有再次点击</strong>的情况才去发起网络请求，对于这种情况我们就可以使用防抖。</p> <blockquote><p>防抖:  我会等你到底。在某段时间内，不管你触发了多少次回调，我都只认最后一次</p></blockquote> <div class="language- extra-class"><pre class="language-text"><code>function fangdou(fn, delay){
    let timer = null;
    return function() {
        if(timer){
            clearTimeout(timer)
        }
        timer = setTimeout(()=&gt;{
            fn()
        }, delay)
    }
}
</code></pre></div></div> <div class="page-edit"><!----> <!----></div> <div class="page-nav"><p class="inner"><span class="prev">
        ←
        <a href="/blog/css.html" class="prev">
          CSS 基础
        </a></span> <span class="next"><a href="/blog/algorithm.html">
          JS算法
        </a>
        →
      </span></p></div> </div> <!----></div></div>
    <script src="/blog/assets/js/app.7cc8aca2.js" defer></script><script src="/blog/assets/js/3.52bd1b81.js" defer></script>
  </body>
</html>
