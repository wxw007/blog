# 策略模式

## 策略模式是啥?
先来一个枯燥的定义: 定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。

我: 啥玩意??? 直接告诉我它能干嘛，什么情况下要用它，用了它能给我带来什么好处就完了！

## 作用: 它能干嘛？
小朋友，你是否有很多if? 

笼统的来说，策略模式就是可以让原本一大堆的 `if-else` 变得更容易维护和扩展。免去我们深入原来的代码进行破坏性的修改；同时如果其他地方需要复用这些逻辑，不需要到处 `ctrl+c ctrl+v` 这样贴狗皮膏。(开放-封闭原则)

## 使用场景
如果我们的代码中有很多`判断逻辑`,就需要考虑是否用策略模式了。

- ~~抄一个~~ 参考一个例子

需求: 根据员工的工资基数以及年底绩效情况来发放的。如：绩效为S的年终奖有4倍工资、绩效为A的年终奖有3倍工资，绩效为B的年终奖只能有2倍的工资。这种逻辑我们可以用基本代码实现

```
// 很耿直的写一个函数，然后直接传参得出结果，简单粗暴

var calculateBonus = function (performanceLevel, salary) {
    if (performanceLevel === 'S') {
        return salary * 4;
    };
    if (performanceLevel === 'A') {
        return salary * 3;
    };
    if (performanceLevel === 'B') {
        return salary * 2;
    };
}

//获得绩效为B的员工 假设该员工工资为 10000
calculateBonus('B', 10000); -> 奖金 20000

//获得绩效为S的员工 假设该员工工资为 10000
calculateBonus('S', 10000); -> 奖金 40000

```
这段代码虽然实现了我们想要的功能，但是很局限，有以下几种缺点：

- 包含了过多的if-else语句，使函数过于庞大。
- calculateBonus函数缺乏弹性，如果需要新增加不同的绩效等级，需要更改其内部实现，违反了开放-封闭原则。
- 算法复用性差，如果其他地方需要用到这种计算规则，只能重新输出（复制、粘贴）。

策略模式就是来专制这种`胖逻辑`的。

## 怎么用

1. 编写策略对象

将各个奖金的计算方法，集中写到一个对象里
```
//策略对象
var strategies = {
    //一系列计算逻辑
    "S" : function ( salary ) {
        return salary * 4;
    },
    "A" : function ( salary ) {
        return salary * 3;
    },
    "B" : function ( salary ) {
        return salary * 2;
    }
};
```

2. 











