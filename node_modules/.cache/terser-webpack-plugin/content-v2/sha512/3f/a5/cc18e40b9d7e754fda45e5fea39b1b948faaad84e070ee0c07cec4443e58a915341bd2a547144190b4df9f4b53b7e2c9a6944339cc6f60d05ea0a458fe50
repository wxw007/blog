{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{356:function(a,t,r){\"use strict\";r.r(t);var e=r(43),n=Object(e.a)({},(function(){var a=this,t=a.$createElement,r=a._self._c||t;return r(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":a.$parent.slotKey}},[r(\"h1\",{attrs:{id:\"策略模式\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#策略模式\"}},[a._v(\"#\")]),a._v(\" 策略模式\")]),a._v(\" \"),r(\"h2\",{attrs:{id:\"策略模式是啥\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#策略模式是啥\"}},[a._v(\"#\")]),a._v(\" 策略模式是啥?\")]),a._v(\" \"),r(\"p\",[a._v(\"先来一个枯燥的定义: 定义一系列的算法，把它们一个个封装起来，并且使它们可以相互替换。\")]),a._v(\" \"),r(\"p\",[a._v(\"我: 啥玩意??? 直接告诉我它能干嘛，什么情况下要用它，用了它能给我带来什么好处就完了！\")]),a._v(\" \"),r(\"h2\",{attrs:{id:\"作用-它能干嘛？\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#作用-它能干嘛？\"}},[a._v(\"#\")]),a._v(\" 作用: 它能干嘛？\")]),a._v(\" \"),r(\"p\",[a._v(\"小朋友，你是否有很多if?\")]),a._v(\" \"),r(\"p\",[a._v(\"笼统的来说，策略模式就是可以让原本一大堆的 \"),r(\"code\",[a._v(\"if-else\")]),a._v(\" 变得更容易维护和扩展。免去我们深入原来的代码进行破坏性的修改；同时如果其他地方需要复用这些逻辑，不需要到处 \"),r(\"code\",[a._v(\"ctrl+c ctrl+v\")]),a._v(\" 这样贴狗皮膏。(开放-封闭原则)\")]),a._v(\" \"),r(\"h2\",{attrs:{id:\"使用场景\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#使用场景\"}},[a._v(\"#\")]),a._v(\" 使用场景\")]),a._v(\" \"),r(\"p\",[a._v(\"如果我们的代码中有很多\"),r(\"code\",[a._v(\"判断逻辑\")]),a._v(\",就需要考虑是否用策略模式了。\")]),a._v(\" \"),r(\"ul\",[r(\"li\",[r(\"s\",[a._v(\"抄一个\")]),a._v(\" 参考一个例子\")])]),a._v(\" \"),r(\"p\",[a._v(\"需求: 根据员工的工资基数以及年底绩效情况来发放的。如：绩效为S的年终奖有4倍工资、绩效为A的年终奖有3倍工资，绩效为B的年终奖只能有2倍的工资。这种逻辑我们可以用基本代码实现\")]),a._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[a._v(\"// 很耿直的写一个函数，然后直接传参得出结果，简单粗暴\\n\\nvar calculateBonus = function (performanceLevel, salary) {\\n    if (performanceLevel === 'S') {\\n        return salary * 4;\\n    };\\n    if (performanceLevel === 'A') {\\n        return salary * 3;\\n    };\\n    if (performanceLevel === 'B') {\\n        return salary * 2;\\n    };\\n}\\n\\n//获得绩效为B的员工 假设该员工工资为 10000\\ncalculateBonus('B', 10000); -> 奖金 20000\\n\\n//获得绩效为S的员工 假设该员工工资为 10000\\ncalculateBonus('S', 10000); -> 奖金 40000\\n\\n\")])])]),r(\"p\",[a._v(\"这段代码虽然实现了我们想要的功能，但是很局限，有以下几种缺点：\")]),a._v(\" \"),r(\"ul\",[r(\"li\",[a._v(\"包含了过多的if-else语句，使函数过于庞大。\")]),a._v(\" \"),r(\"li\",[a._v(\"calculateBonus函数缺乏弹性，如果需要新增加不同的绩效等级，需要更改其内部实现，违反了开放-封闭原则。\")]),a._v(\" \"),r(\"li\",[a._v(\"算法复用性差，如果其他地方需要用到这种计算规则，只能重新输出（复制、粘贴）。\")])]),a._v(\" \"),r(\"p\",[a._v(\"策略模式就是来专制这种\"),r(\"code\",[a._v(\"胖逻辑\")]),a._v(\"的。\")]),a._v(\" \"),r(\"h2\",{attrs:{id:\"怎么用\"}},[r(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#怎么用\"}},[a._v(\"#\")]),a._v(\" 怎么用\")]),a._v(\" \"),r(\"ol\",[r(\"li\",[a._v(\"编写策略对象\")])]),a._v(\" \"),r(\"p\",[a._v(\"将各个奖金的计算方法，集中写到一个对象里\")]),a._v(\" \"),r(\"div\",{staticClass:\"language- extra-class\"},[r(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[r(\"code\",[a._v('//策略对象\\nvar strategies = {\\n    //一系列计算逻辑\\n    \"S\" : function ( salary ) {\\n        return salary * 4;\\n    },\\n    \"A\" : function ( salary ) {\\n        return salary * 3;\\n    },\\n    \"B\" : function ( salary ) {\\n        return salary * 2;\\n    }\\n};\\n')])])]),r(\"ol\",{attrs:{start:\"2\"}},[r(\"li\")])])}),[],!1,null,null,null);t.default=n.exports}}]);","extractedComments":[]}